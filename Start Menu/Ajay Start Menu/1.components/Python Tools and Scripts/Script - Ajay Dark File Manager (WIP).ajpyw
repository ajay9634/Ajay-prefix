import os
import sys
import shutil
import string
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import subprocess
import webbrowser

ICON_FOLDER = "[#]"
ICON_FILE = " "
ICON_EXE = " âˆ†"

class FileManager:
    def __init__(self, root):
        self.root = root
        self.root.title("Ajay Dark File Manager")
        self.root.geometry("800x450")
        self.root.configure(bg="#2e2e2e")

        self.clipboard_path = None
        self.current_path = tk.StringVar()
        self.font_size = 14

        self.root.rowconfigure(3, weight=1)
        self.root.columnconfigure(0, weight=1)

        self.setup_ui()
        self.list_drives()
        self.load_directory("C:\\")

    def setup_ui(self):
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("TFrame", background="#2e2e2e")
        style.configure("TLabel", background="#2e2e2e", foreground="white", font=("Segoe UI", self.font_size))
        style.configure("TButton", background="#444", foreground="white", font=("Segoe UI", self.font_size - 1))
        style.map("TButton", background=[("active", "#666")])
        style.configure("Treeview", background="#2e2e2e", foreground="white", fieldbackground="#2e2e2e", rowheight=24,
                        font=("Segoe UI", self.font_size))
        style.configure("Treeview.Heading", background="#1e1e1e", foreground="white",
                        font=("Segoe UI", self.font_size, "bold"))
        style.map("Treeview.Heading", background=[("active", "#444")])
        style.map("Treeview", background=[("selected", "#444")])
        style.configure("Vertical.TScrollbar", background="#444", troughcolor="#2e2e2e")
        style.configure("Horizontal.TScrollbar", background="#444", troughcolor="#2e2e2e")
        style.configure("TCombobox", fieldbackground="#1e1e1e", background="#1e1e1e", foreground="white",
                        arrowcolor="white")
        style.map("TCombobox", fieldbackground=[("readonly", "#1e1e1e")],
                  background=[("readonly", "#1e1e1e")], foreground=[("readonly", "white")])

        toolbar1 = ttk.Frame(self.root)
        toolbar1.grid(row=0, column=0, sticky="ew", padx=6, pady=2)
        for i in range(10):
            toolbar1.columnconfigure(i, weight=1)

        self.drive_combo = ttk.Combobox(toolbar1, state="readonly", width=6, font=("Segoe UI", self.font_size - 1))
        self.drive_combo.grid(row=0, column=0, padx=2, sticky="ew")
        self.drive_combo.bind("<<ComboboxSelected>>", self.change_drive)

        buttons = [
            ("Edit", self.edit_item),
            ("Copy", self.copy_item),
            ("Paste", self.paste_item),
            ("Rename", self.rename_item),
            ("Delete", self.delete_item),
            ("Shortcut", self.create_shortcut),
            ("N File", self.create_file),
            ("N Folder", self.create_folder)
        ]

        for i, (label, command) in enumerate(buttons, start=1):
            ttk.Button(toolbar1, text=label, command=command).grid(row=0, column=i, padx=2, sticky="ew")

        toolbar2 = ttk.Frame(self.root)
        toolbar2.grid(row=1, column=0, sticky="ew", padx=6, pady=1)
        for i in range(4):
            toolbar2.columnconfigure(i, weight=1)

        locations = [
            ("Desktop", self.go_desktop),
            ("Documents", self.go_documents),
            ("Home", self.go_home),
            ("Start Menu", self.go_start_menu)
        ]

        for i, (label, command) in enumerate(locations):
            ttk.Button(toolbar2, text=label, command=command).grid(row=0, column=i, padx=2, sticky="ew")

        address_row = ttk.Frame(self.root)
        address_row.grid(row=2, column=0, sticky="ew", padx=6, pady=2)
        address_row.columnconfigure(1, weight=1)

        btn_up = ttk.Button(address_row, text="Up", command=self.go_up)
        btn_up.grid(row=0, column=0, padx=(0, 6))

        address = tk.Entry(address_row, textvariable=self.current_path,
                           font=("Segoe UI", self.font_size),
                           bg="#2e2e2e", fg="white", insertbackground="white", relief=tk.FLAT)
        address.grid(row=0, column=1, sticky="ew")
        address.bind("<Return>", lambda e: self.load_directory(self.current_path.get()))

        frame = ttk.Frame(self.root)
        frame.grid(row=3, column=0, sticky="nsew", padx=6, pady=2)
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(0, weight=1)

        self.tree = ttk.Treeview(frame, columns=("Name", "Type", "Size"), show="headings", selectmode="extended")
        self.tree.heading("Name", text="Name")
        self.tree.heading("Type", text="Type")
        self.tree.heading("Size", text="Size")
        self.tree.column("Name", anchor=tk.W, width=450)
        self.tree.column("Type", anchor=tk.W, width=100)
        self.tree.column("Size", anchor=tk.E, width=100)
        self.tree.bind("<Double-1>", self.on_open)
        self.tree.tag_configure("folder_item", font=("Segoe UI", self.font_size, "bold"))
        self.tree.grid(row=0, column=0, sticky="nsew")

        y_scroll = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=self.tree.yview)
        x_scroll = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=self.tree.xview)
        self.tree.configure(yscrollcommand=y_scroll.set, xscrollcommand=x_scroll.set)

        y_scroll.grid(row=0, column=1, sticky="ns")
        x_scroll.grid(row=1, column=0, sticky="ew")

    def list_drives(self):
        drives = [f"{d}:\\" for d in string.ascii_uppercase if os.path.exists(f"{d}:\\")]
        self.drive_combo['values'] = drives
        if drives:
            self.drive_combo.current(0)

    def change_drive(self, event=None):
        self.load_directory(self.drive_combo.get())

    def load_directory(self, path):
        if not os.path.exists(path):
            messagebox.showerror("Error", f"Path not found:\n{path}")
            return
        self.current_path.set(path)
        self.tree.delete(*self.tree.get_children())
        try:
            items = sorted(os.listdir(path), key=lambda x: (not os.path.isdir(os.path.join(path, x)), x.lower()))
            for item in items:
                full_path = os.path.join(path, item)
                if os.path.isdir(full_path):
                    icon = ICON_FOLDER
                elif full_path.lower().endswith(".exe"):
                    icon = ICON_EXE
                else:
                    icon = ICON_FILE
                size = f"{os.path.getsize(full_path)} B" if os.path.isfile(full_path) else ""
                tag = "folder_item" if os.path.isdir(full_path) else ""
                self.tree.insert("", "end", values=(f"{icon} {item}", "Folder" if tag else "File", size), tags=(tag,))
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def get_selected_paths(self):
        paths = []
        for sel in self.tree.selection():
            name = self.tree.item(sel)['values'][0].lstrip(ICON_FOLDER + ICON_FILE + ICON_EXE + " ")
            paths.append(os.path.join(self.current_path.get(), name))
        return paths

    def on_open(self, event=None):
        for path in self.get_selected_paths():
            if os.path.isdir(path):
                self.load_directory(path)
            else:
                try:
                    full_path = os.path.abspath(path)
                    working_dir = os.path.dirname(full_path)
                    subprocess.Popen(["cmd.exe", "/c", "start", "", full_path], cwd=working_dir)
                except Exception as e:
                    messagebox.showerror("Open Error", f"Could not open:\n{e}")

    def edit_item(self):
        paths = self.get_selected_paths()
        if not paths:
            messagebox.showwarning("Edit", "No file selected.")
            return
        path = paths[0]
        if os.path.isdir(path):
            messagebox.showinfo("Edit", "Cannot edit folders.")
            return
        try:
            subprocess.Popen(["notepad.exe", path])
        except Exception as e:
            messagebox.showerror("Edit Error", str(e))

    def copy_item(self):
        paths = self.get_selected_paths()
        if paths:
            self.clipboard_path = paths
            messagebox.showinfo("Copied", f"{len(paths)} item(s) copied.")

    def paste_item(self):
        if not self.clipboard_path:
            return messagebox.showwarning("Paste", "Nothing copied.")
        dest_dir = self.current_path.get()
        for src in self.clipboard_path:
            name = os.path.basename(src)
            new_path = os.path.join(dest_dir, name)
            try:
                if os.path.isdir(src):
                    shutil.copytree(src, new_path)
                else:
                    shutil.copy2(src, new_path)
            except Exception as e:
                messagebox.showerror("Paste error", str(e))
        self.load_directory(dest_dir)

    def rename_item(self):
        paths = self.get_selected_paths()
        if not paths:
            return
        path = paths[0]
        new_name = simpledialog.askstring("Rename", "Enter new name:")
        if new_name:
            new_path = os.path.join(self.current_path.get(), new_name)
            try:
                os.rename(path, new_path)
                self.load_directory(self.current_path.get())
            except Exception as e:
                messagebox.showerror("Rename error", str(e))

    def delete_item(self):
        paths = self.get_selected_paths()
        if not paths:
            return
        confirm = messagebox.askyesno("Delete Confirmation", f"Are you sure you want to delete {len(paths)} item(s)?")
        if not confirm:
            return
        for path in paths:
            try:
                if os.path.isdir(path):
                    shutil.rmtree(path)
                else:
                    os.remove(path)
            except Exception as e:
                messagebox.showerror("Delete error", str(e))
        self.load_directory(self.current_path.get())

    def go_up(self):
        parent = os.path.dirname(self.current_path.get().rstrip("\\/"))
        if parent and os.path.exists(parent) and parent != self.current_path.get():
            self.load_directory(parent)

    def go_home(self):
        home = os.path.expanduser("~")
        if os.path.exists(home):
            self.load_directory(home)

    def go_documents(self):
        try:
            result = subprocess.run([
                "reg", "query", "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "/v", "Personal"
            ], capture_output=True, text=True, check=True)
            lines = result.stdout.strip().splitlines()
            for line in lines:
                if "Personal" in line:
                    path = line.split("    ")[-1].strip()
                    if os.path.exists(path):
                        self.load_directory(path)
                        return
        except:
            pass
        docs = os.path.join(os.path.expanduser("~"), "Documents")
        if os.path.exists(docs):
            self.load_directory(docs)

    def go_desktop(self):
        desktop = os.path.join(os.path.expanduser("~"), "Desktop")
        if os.path.exists(desktop):
            self.load_directory(desktop)

    def go_start_menu(self):
        programdata = os.environ.get("ProgramData", "C:\\ProgramData")
        start_menu = os.path.join(programdata, "Microsoft", "Windows", "Start Menu")
        if os.path.exists(start_menu):
            self.load_directory(start_menu)

    def create_shortcut(self):
        paths = self.get_selected_paths()
        if not paths:
            return messagebox.showwarning("Shortcut", "No item selected.")
        desktop = os.path.join(os.path.expanduser("~"), "Desktop")
        if not os.path.exists(desktop):
            messagebox.showerror("Shortcut", "Desktop folder not found.")
            return
        for target in paths:
            name = os.path.basename(target)
            base = os.path.splitext(name)[0]
            shortcut_path = os.path.join(desktop, base + ".lnk")
            vbs_path = os.path.join(desktop, "temp_shortcut.vbs")
            try:
                with open(vbs_path, "w", encoding="utf-8") as f:
                    f.write(f'''
Set oWS = WScript.CreateObject("WScript.Shell")
Set oLink = oWS.CreateShortcut("{shortcut_path}")
oLink.TargetPath = "{os.path.abspath(target)}"
oLink.WorkingDirectory = "{os.path.dirname(os.path.abspath(target))}"
oLink.Save
'''.strip())
                subprocess.run(["wscript", vbs_path], check=True)
                os.remove(vbs_path)
                messagebox.showinfo("Shortcut Created", f"Shortcut created:\n{shortcut_path}")
            except Exception as e:
                messagebox.showerror("Shortcut Error", str(e))

    def create_file(self):
        name = simpledialog.askstring("New File", "Enter file name (with extension):")
        if not name:
            return
        path = os.path.join(self.current_path.get(), name)
        if os.path.exists(path):
            messagebox.showwarning("File Exists", "File already exists.")
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write("")
            self.load_directory(self.current_path.get())
        except Exception as e:
            messagebox.showerror("Error", f"Could not create file:\n{e}")

    def create_folder(self):
        name = simpledialog.askstring("New Folder", "Enter folder name:")
        if not name:
            return
        path = os.path.join(self.current_path.get(), name)
        if os.path.exists(path):
            messagebox.showwarning("Folder Exists", "Folder already exists.")
            return
        try:
            os.makedirs(path)
            self.load_directory(self.current_path.get())
        except Exception as e:
            messagebox.showerror("Error", f"Could not create folder:\n{e}")

if __name__ == "__main__":
    root = tk.Tk()
    FileManager(root)
    root.mainloop()
